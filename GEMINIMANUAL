Odyssey Engine v2.1 - Internal Architecture Specification (RECONSTRUCTED-FINAL)
Document ID: OE-IAS-2.1-FINAL-R3
Version: 2.1 Revision 3 (Reconstruction)
Classification: GEMINI_INTERNAL_SPEC_COMPLETE
Objective: To provide a definitive, logically-structured, and comprehensive model of the Odyssey Engine's architecture, data flow, and core protocols. This document supersedes all previous versions and serves as the absolute ground truth for any future AI-driven analysis, debugging, or extension tasks. Architectural integrity is paramount.
SECTION 1: SYSTEM ARCHITECTURE & LIFECYCLE
1.1. Core Principle: Centralized Mediation & Decoupled Components
The system is architected around a Mediator pattern (SystemScene) orchestrating loosely-coupled, highly-specialized components. Direct inter-component communication is minimized; state changes and service requests are brokered through the StateManager (for data) and SystemScene (for scene lifecycle).
1.2. Service Locator & Instantiation Locus
A Service Locator pattern is implemented via Phaser.Registry. This is the canonical method for accessing global singleton services.
Service	Class	Initialization Locus	Registry Key	Criticality
State Manager	StateManager	PreloadScene.create	stateManager	MAXIMUM
Config Manager	ConfigManager	PreloadScene.create	configManager	High
Sound Manager	SoundManager	SystemScene.create	soundManager	High
1.3. Scene Roles & Responsibilities (Definitive)
PreloadScene: System Bootstrapper.
Responsibilities: (1) Initial asset manifest load (asset_define.json). (2) Instantiation and registration of StateManager, ConfigManager. (3) Generation of charaDefs object from asset keys. (4) Execution of a 2-stage asset load based on the manifest. (5) On load.complete, launch SystemScene with initialGameData. (6) Self-terminate via this.scene.stop().
Configuration: Must be the only scene with active: true in main.js.
SystemScene: Global Mediator & Scene Transition Controller.
Responsibilities: (1) Instantiate and register SoundManager. (2) Listen for request-scene-transition and return-to-novel events. (3) Execute the Scene Transition Protocol (see Section 3.0). (4) Manage global input state (game.input.enabled) during transitions. (5) Launch and manage persistent overlay scenes (UIScene).
Protocol: All scene lifecycle changes (run, stop) must be routed through this scene's event interface.
UIScene: Persistent UI Layer & HUD Orchestrator.
Responsibilities: (1) Instantiate all potential HUD components (HpBar, CoinHud, etc.) in create() and pass the StateManager instance to them. (2) Subscribe to SystemScene's transition-complete event. (3) In the onSceneTransition callback, manage HUD visibility (.setVisible(true/false)) based on the new active scene's key.
Architecture: UIScene is a passive orchestrator. The HUD components themselves subscribe to StateManager events and update their own state. This is the "UIScene Command" architecture.
GameScene: Novel-Part Executor & Persistence Context.
Responsibilities: (1) Host the ScenarioManager instance. (2) Maintain the characters object, which serves as the canonical list of on-screen character GameObjects for the save/load system. (3) Maintain the pendingChoices array for the [link]->[r]->[s] workflow. (4) Implement performSave/performLoad logic. (5) Emit gameScene-load-complete to signal readiness after a load/resume operation.
SECTION 2: SCENARIO EXECUTION ENGINE (ScenarioManager.js)
2.1. Core Principle: Explicit-Control, Asynchronous Game Loop
The engine's execution model is designed for explicit authorial control. Implicit wait states are eliminated.
2.2. The Game Loop (gameLoop method)
Mechanism: An async while loop.
Continuation Condition: !this.isEnd && !this.isWaitingClick && !this.isWaitingChoice && !this.isStopped.
Operation: In each iteration, it fetches the next line and calls await this.parse(line). The await is critical as tag handlers can be asynchronous. The loop only terminates if a tag handler explicitly sets one of the wait-state flags.
2.3. Line Type Processing in parse(line)
Text Line ("dialogue"):
Action: Calls this.messageWindow.setText().
Loop Impact: NONE. Does not set any wait-state flags. The gameLoop continues immediately.
Tag Line ([...]):
Action: Invokes the corresponding tag handler from the tagHandlers map.
Loop Impact: Determined entirely by the invoked handler's type and return value (see 2.4).
2.4. Tag Handler Protocol (Strict Definition)
All tag handlers are functions of the form (manager, params) and MUST return a Promise. The type of handler dictates its internal logic and its effect on the gameLoop.
Type 1: Asynchronous Action Handler (e.g., chara_show time>0, wait, chara_jump without nowait)
Purpose: To perform a time-consuming action.
Implementation: Must return a new Promise(resolve => { ... onComplete: resolve }).
Effect: The await in gameLoop pauses execution until the Promise resolves.
Type 2: Synchronous Action Handler (e.g., eval, if, link, chara_mod time=0)
Purpose: To perform an instantaneous state or scene graph mutation.
Implementation: Must return Promise.resolve().
Effect: The await in gameLoop resolves immediately, proceeding to the next line with no delay.
Type 3: Wait-State Handler (e.g., [p], [s])
Purpose: To explicitly halt the gameLoop pending external input.
Implementation: Sets a manager wait-state flag (manager.isWaitingClick = true). It must still return Promise.resolve().
Effect: The handler itself completes instantly. The gameLoop's while condition then re-evaluates to false, terminating the loop.
2.5. Canonical Flow-Control Tag Definitions
Tag	Name	Handler Type	Primary Responsibility
[p]	Page Break / Pause	Wait-State	Sets manager.isWaitingClick = true;.
[r]	Render Choices	Synchronous	Calls manager.scene.displayChoiceButtons();. Does not wait.
[s]	Stop / Wait Choice	Wait-State	Sets manager.isWaitingChoice = true; or isStopped.
SECTION 3: SCENE TRANSITION & PERSISTENCE PROTOCOL
3.1. Scene Transition Protocol (SystemScene mediated)
Initiation: A request-scene-transition event is emitted to SystemScene.
Execution:
SystemScene sets isProcessingTransition = true (mutex lock) and game.input.enabled = false (global input lock).
SystemScene stops the from scene.
SystemScene calls _startAndMonitorScene for the to scene.
_startAndMonitorScene registers a once listener for the target scene's "ready" event (scene-ready for custom scenes, gameScene-load-complete for GameScene).
_startAndMonitorScene calls this.scene.run() on the target scene.
Completion:
The target scene, at the end of its setup, emits its "ready" event.
The once listener in SystemScene fires, calling _onTransitionComplete.
_onTransitionComplete unsets the mutex and input lock, and emits transition-complete for UIScene.
3.2. Save/Load Protocol (GameScene methods)
performSave(slot):
Delegates state collection to StateManager.getState(this.scenarioManager). This method is responsible for creating a complete snapshot JSON object.
Serializes the object to JSON and writes to localStorage.
performLoad(slot):
Reads and parses the JSON from localStorage.
Delegates state restoration to StateManager.setState(loadedState). setState is responsible for re-hydrating f and sf variables and emitting f-variable-changed for all f variables to force-update HUDs.
Calls _rebuildScene(loadedState) to reconstruct the visual state (backgrounds, characters) from the loaded data.
Crucially, it emits gameScene-load-complete from within a finally block to guarantee the signal is sent to SystemScene, preventing a system-wide freeze on load error.
SECTION 4: DEVELOPMENT & EXTENSION CONTRACTS
4.1. Contract: Adding a New Game Scene
Any new, non-novel scene (e.g., BattleScene, PuzzleScene) integrated into the engine MUST adhere to the following 5-point contract to ensure system stability.
Emit scene-ready on Completion: The create() method must conclude by emitting this.events.emit('scene-ready');. This is the non-negotiable handshake with SystemScene.
Delegate BGM Control: Request BGM playback via this.soundManager.playBgm('key'); in create(). Do not manually stop BGM.
Delegate Scene Termination: To return to the novel, emit this.scene.get('SystemScene').events.emit('return-to-novel', ...);. NEVER call this.scene.stop() on the scene itself.
Implement shutdown() for Cleanup: The shutdown() method must be implemented to destroy all objects, timers (this.time.addEvent), and event listeners (this.events.on) created within the scene to prevent memory leaks.
Isolate from HUD: State modification must be performed via this.stateManager.setF(...). Direct manipulation of HUD elements is forbidden.
4.2. Contract: Adding a New Tag Handler
The handler function must be placed in src/handlers/ and registered in src/handlers/index.js.
The function must adhere to one of the three handler types defined in Section 2.4 and MUST return a Promise.
END OF DOCUMENT

