## **3. AI向け仕様書 (GEMINI INTERNAL SPECIFICATION) - Odyssey Engine v1.0**

**目的:** このドキュメントは、Odyssey Engineの内部アーキテクチャ、データフロー、およびコンポーネント間の相互作用を、AIが最大限に理解し、将来的な機能拡張やデバッグ、特に**ノベル以外のゲームジャンルとのシームレスな連携**を効率的に支援するためのものです。人間が読むことよりも、AIによる機械的・論理的解釈の最適化を優先します。
まあつまり...、最初に食わせて使い方を学習させる為のリードミーです。
**1.0 Core Architecture & Data Flow**
*   **VIEWPORT**: `1280x720`, `Phaser.Scale.FIT`. Layout coordinates are always relative to this resolution.
*   **SCENE LIFECYCLE MANAGEMENT**: Centralized via `SystemScene` events. Direct `scene.start/stop/pause/resume/launch` calls are minimized outside `SystemScene` for inter-scene communication.
*   **KEY SCENE ROLES**:
    *   `PreloadScene`: Bootstrap (Load `asset_define.json`, `ConfigManager` init, `charaDefs` generation/pass to `GameScene`).
    *   `GameScene`: Novel Core (Instantiates `ScenarioManager`, `SoundManager`, `StateManager`, `MessageWindow`. Owns core Save/Load logic).
    *   `UIScene`: Persistent UI (Always `active:true`).
    *   `SystemScene`: **Global Mediator & Scene Traffic Controller**. (Always `active:true`). Handles all inter-scene communication events (transition, overlay, return). **CRITICAL for ensuring `charaDefs` and other parameters are passed consistently.**
    *   `NovelOverlayScene`: Overlay Novel Layer (Launched via `SystemScene`. Runs its own `ScenarioManager` instance atop another scene. Uses dedicated `inputBlocker` for input isolation).
    *   `ActionScene` (Example Non-Novel Scene): Integrates with `SystemScene` for transition/return control.

*   **STATE MANAGEMENT (`StateManager.js`)**: **Centralized Source of Truth for Game State.**
    *   `this.f`: `(Object)` Game variables (e.g., `f.score`).
    *   `this.sf`: `(Object)` System variables (e.g., `sf.boot_count`, `sf.history`). Persisted automatically on modification via `eval()` or `addHistory()`.
    *   `getState(scenarioManager: ScenarioManager)`: `(Method)` **Snapshot**. Collects ALL dynamic game state for persistence.
        *   **Sources**: `scenarioManager.currentFile/Line/ifStack/callStack/isWaitingClick/isWaitingChoice`, `scenarioManager.messageWindow.currentText/currentSpeaker`, `scenarioManager.scene.characters` (visual state), `scenarioManager.layers.background` (visual state), `scenarioManager.soundManager.getCurrentBgmKey()`.
        *   **Output**: A deep-copied JSON-serializable Object.
    *   `setState(loadedState: Object)`: `(Method)` **Restore**. Replaces `this.f` with `loadedState.variables.f`. (Does NOT directly update visual/scenario state; that's `rebuildScene`'s job).
    *   `eval(exp: string)`: `(Method)` Executes JS expression `exp` in a controlled scope (`f`, `sf` available). **CRITICAL**: Calls `this.saveSystemVariables()` after execution to persist `sf` changes.

*   **ASSET & DEFINITION FLOW**:
    *   `asset_define.json`: Primary asset manifest.
    *   `charaDefs`: Generated by `PreloadScene` from `asset_define.json`. Passed to `GameScene` on initial boot. **CRITICAL**: `SystemScene` stores `this.globalCharaDefs` from `GameScene`'s first `create()`, and **passes it to ALL `scene.start/launch` calls (`GameScene`, `NovelOverlayScene`, `ActionScene`) for consistent availability.**

**2.0 Execution Control (`ScenarioManager.js`)**
*   **Master Game Loop (CRITICAL)**: `next()` -> `gameLoop()` -> `parse()`
    *   `next()`: `(Method)` Entry point for advancing scenario. Resets `isWaitingClick/Choice` flags. Calls `gameLoop()`.
    *   `gameLoop()`: `(async Method)` **The core `while` loop**: `while (!this.isEnd && !this.isWaitingClick && !this.isWaitingChoice)`. Continuously `await this.parse(line)` until a wait condition (`isWaitingClick/Choice` becomes `true`) or end condition (`isEnd` becomes `true`) is met. This ensures **guaranteed progression or intentional halt, preventing infinite synchronous loops.**
    *   `parse(line: string)`: `(async Method)` Processes a single scenario line.
        *   **Flow**: Uses a strict `if-else if-else` chain to prevent falling through to incorrect handlers (e.g., tags being parsed as dialogue).
        *   **CRITICAL**: All `parse` logic (including `ifStack` manipulation, `isWaitingClick/Choice` flags) directly modifies `ScenarioManager`'s state. `parse` itself **does not call `next()` or return a boolean for continuation.** The `gameLoop()`'s `while` condition checks the state after `await this.parse(line)` resolves.
*   **Tag Handler Protocol (CRITICAL - ALL HANDLERS)**:
    *   All tag handler functions (`handleXyz(manager, params)`) **MUST return a `Promise<void>`**.
        *   **Synchronous Handlers** (`eval`, `if`, `delay`, `playse`, `cm`, `er`, `s`, `log`, `link`, `button`, `stop_anim`, `endif`, `elsif`, `else`): Execute logic, then `return Promise.resolve();`. This ensures `gameLoop()` yields control to the event loop, even for instant operations, preventing stack overflow.
        *   **Asynchronous Handlers** (`chara_show`, `move`, `wait`, `bg`, `fadein/out`, `chara_jump`, `flip`, `playbgm`, `stopbgm`, `walk`, `vibrate`, `shake`, `image`, `freeimage`, `video`, `stopvideo`): Initiate async operation (e.g., Tween, `delayedCall`), and `resolve()` the returned Promise in the operation's `onComplete` callback.
        *   **Player-Wait Handlers** (`p`, `button`): Set `manager.isWaitingClick = true` or `manager.isWaitingChoice = true`. Return `Promise.resolve()`. `gameLoop()` will then detect the wait flag and halt.
        *   **Flow-Control Handlers** (`jump`, `call`, `return`, `overlay_end`): Manipulate `manager.currentLine/currentFile/callStack`, or emit events to `SystemScene`. They **DO NOT** call `next()`. They return `Promise.resolve()` (for immediate processing) or `Promise` (if SystemScene interaction is async).

**3.0 Inter-Scene Communication Protocol (SystemScene as Central Hub)**
*   **Mechanism**: `SystemScene` listens for specific events emitted by `GameScene`, `ActionScene`, `NovelOverlayScene`, and tag handlers.
*   **Transition Flow (`GameScene/ActionScene` <-> `ActionScene/GameScene`)**:
    *   `[jump storage="SceneKey"]` (from `handleJump`):
        *   **CRITICAL**: `manager.scene.performSave(0)` (auto-save) is called **before** event emission.
        *   Emits `'request-scene-transition'` to `SystemScene` (`{to: 'SceneKey', from: 'GameScene'}`).
        *   `SystemScene` `stop()`s `GameScene/UIScene`, `start()`s target scene (`ActionScene`/`GameScene`).
        *   **CRITICAL**: `SystemScene` **MUST** pass `charaDefs` to the `start()` call.
    *   Return (`ActionScene` -> `GameScene`):
        *   `ActionScene` emits `'return-to-novel'` to `SystemScene` (`{from: 'ActionScene', params: {...}}`).
        *   `SystemScene` `stop()`s `ActionScene`, `start()`s `GameScene` (in `resumedFrom` mode), `launch()`s `UIScene`.
        *   `GameScene.create()` detects `resumedFrom` and calls `performLoad(0, returnParams)` to restore state and apply `returnParams`.
    *   **CRITICAL**: Input (`input.enabled`) for `GameScene` and `UIScene` is **explicitly set to `true` by `SystemScene` after `start/launch`** when returning to novel. `ActionScene`'s `resume()` method handles its own `input.enabled = true;` when its `scene.resume()` is called by `SystemScene`.
*   **Overlay Flow (`ActionScene` <-> `NovelOverlayScene`)**:
    *   `ActionScene` emits `'request-overlay'` to `SystemScene` (`{from: 'ActionScene', scenario: '...'}`).
    *   **CRITICAL**: `SystemScene` **does NOT `pause()` `ActionScene`**. `ActionScene` remains active.
    *   `SystemScene` `launch()`es `NovelOverlayScene`.
    *   `NovelOverlayScene` handles input isolation via its internal `inputBlocker` (transparent, `setInteractive()`, `input.enabled` controlled via `displayChoiceButtons/clearChoiceButtons`).
    *   `[overlay_end]` tag (in `NovelOverlayScene`): Emits `'end-overlay'` to `SystemScene` (`{from: 'NovelOverlayScene', returnTo: 'ActionScene'}`).
    *   `SystemScene` `stop()`s `NovelOverlayScene`. **CRITICAL**: `SystemScene` **MUST** explicitly set `returnTo` scene's `input.enabled = true;` (e.g., `ActionScene`) if it was made `false` by `request-overlay`. (Note: Current implementation explicitly enables `input.enabled = true` on `end-overlay`).
*   **`[CALL storage="SceneKey"]` (e.g., `ActionScene`)**: **(RECOMMEND AGAINST THIS)** While `handleCall` will push to `callStack` and then `SystemScene` handles the transition, `return-to-novel` from `ActionScene` does **NOT** pop from `callStack`. This can lead to `callStack` inconsistencies if `[return]` is used later without corresponding `[call]`s. **Prefer `[jump storage="SceneKey"]` for transitioning to non-novel Phaser Scenes.**

**4.0 Save/Load Protocol (CRITICAL - Data Persistence)**
*   **Mechanism**: `GameScene` is responsible for `performSave/Load`. `StateManager` handles data collection/restoration. `localStorage` is the storage medium.
*   **`performSave(slot: number)`**:
    *   Calls `this.stateManager.getState(this.scenarioManager)` to capture full game state.
    *   Stringifies and stores to `localStorage.setItem(save_data_${slot})`.
*   **`performLoad(slot: number, returnParams: Object | null)`**:
    *   Loads JSON from `localStorage`.
    *   `this.stateManager.setState(loadedState)`: Restores `this.f` variables.
    *   **CRITICAL**: If `returnParams` exist, their values (`f.battle_result='win'`) are applied to `StateManager`'s `this.f` via `this.stateManager.eval(evalExp)` *after* `setState`.
    *   `rebuildScene(this.scenarioManager, loadedState)`: **Main reconstruction logic.** Clears current display, sets `ScenarioManager`'s internal state (`currentLine`, `ifStack`, `callStack`, `isWaitingClick/Choice`), re-creates visual elements (background, characters, BGM), restores `MessageWindow` text/speaker, and recreates choice buttons if `isWaitingChoice` was true.
    *   **CRITICAL**: `performLoad` decides whether to call `scenarioManager.next()` based on `loadedState.scenario.isWaitingClick/Choice`. If `true`, it waits for user input. Otherwise, it calls `next()` to resume.
*   **Autosave/Autoload**: `slot=0` is reserved for autosave (used by `handleJump/Call` before transition) and autoload (by `GameScene.create()` on `resumedFrom`).
*   **Data Integrity**: All data (`f`, `sf`, `ifStack`, `callStack`, `currentLine`, `pendingChoices`, etc.) is captured and restored through this centralized mechanism, ensuring full state persistence.
